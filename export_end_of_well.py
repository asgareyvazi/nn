# export_end_of_well.py
"""
Enhanced End Of Well Report exporter
- Produces DOCX with cover, TOC placeholder, structured sections, charts, images
- Inserts logos (Preferences.logo_company / logo_client) if available
- Inserts bit photos (photo_before / photo_after) when present
- Inserts signature image from Signoff.sign_image_path if available
- Can convert to PDF via docx2pdf (optional)
"""

import os
from io import BytesIO
from pathlib import Path
from datetime import datetime
from typing import Optional

from docx import Document
from docx.shared import Pt, Inches
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.oxml.ns import qn
from PIL import Image

import matplotlib.pyplot as plt

from database import Database
from models import (
    Well, Section, DailyReport, TimeLog, DrillingParameters, MudReport, MudChemical,
    BitRecord, BitRunReport, BHARun, BHATool, InventoryItem, MaterialNote, BOPRecord,
    Crew, Survey, Preferences, Signoff
)

def fmt_date(d):
    if d is None: return ""
    try:
        return d.isoformat()
    except:
        return str(d)

class EndOfWellExporter:
    def __init__(self, db: Database, template_docx: Optional[str] = None):
        self.db = db
        self.template_docx = template_docx

    def export_well_report(self, well_id: int, out_path: str, export_pdf: bool = False, include_sections: Optional[list] = None, embed_images: bool = True):
        """
        Export the EOWR for a well to out_path (.docx preferred). Optionally convert to PDF.
        include_sections: list of section ids/names to include.
        embed_images: if true, will attempt to embed bit images and sign images.
        """
        with self.db.get_session() as s:
            well = s.query(Well).get(well_id)
            if not well:
                raise ValueError(f"Well id {well_id} not found")

            doc = Document(self.template_docx) if self.template_docx and Path(self.template_docx).exists() else Document()
            self._set_styles(doc)

            # cover with logos
            prefs = s.query(Preferences).first()
            self._add_cover(doc, well, prefs)

            # TOC placeholder
            p = doc.add_paragraph(); p.alignment = WD_ALIGN_PARAGRAPH.CENTER
            p.add_run("Table of Contents").bold = True
            doc.add_paragraph("<<Open this document in Word and update the TOC to get clickable entries.>>")
            doc.add_page_break()

            # well info
            self._section_well_info(doc, well)

            # daily reports (by section & date)
            self._section_daily_reports(doc, well, s, include_sections)

            # timelog & npt summary (charts)
            self._section_timelog_npt(doc, well, s, include_sections)

            # drilling parameters
            self._section_drilling_params(doc, well, s)

            # mud
            self._section_mud(doc, well, s)

            # bits (with photos) and BHA
            self._section_bits(doc, well, s, embed_images)
            self._section_bha(doc, well, s)

            # inventory, materials
            self._section_inventory_materials(doc, well, s)

            # safety & BOP
            self._section_safety(doc, well, s)

            # services & POB
            self._section_services_pob(doc, well, s)

            # appendices (surveys)
            self._section_appendices(doc, well, s)

            # signoff
            self._section_signoff(doc, well, s, embed_images)

            # generation stamp
            doc.add_paragraph()
            doc.add_paragraph(f"Generated by Nikan Drill Master â€” {datetime.utcnow().isoformat(timespec='seconds')}Z")

            # save docx
            out_path = Path(out_path)
            if out_path.suffix.lower() not in (".docx", ".pdf"):
                out_path = out_path.with_suffix(".docx")
            docx_path = out_path if out_path.suffix.lower() == ".docx" else out_path.with_suffix(".docx")
            doc.save(str(docx_path))

            # convert to PDF if requested
            if export_pdf or out_path.suffix.lower() == ".pdf":
                try:
                    from docx2pdf import convert
                    convert(str(docx_path), str(out_path))
                except Exception as e:
                    raise RuntimeError("PDF conversion failed. docx saved. Error: " + str(e))

        return str(out_path)

    # ---------------- Styles & helpers ----------------
    def _set_styles(self, doc: Document):
        style = doc.styles['Normal']
        style.font.name = 'Calibri'; style._element.rPr.rFonts.set(qn('w:eastAsia'), 'Calibri'); style.font.size = Pt(11)

    def _try_insert_image(self, doc, img_path, width_in_inches=5):
        try:
            if not img_path or not Path(img_path).exists():
                return False
            # Insert image (resize if too large)
            img = Image.open(img_path)
            # Optionally resize to width
            width_px, height_px = img.size
            # convert px to inches via DPI if available
            dpi = img.info.get("dpi", (96,96))[0]
            # set width
            doc.add_picture(img_path, width=Inches(width_in_inches))
            return True
        except Exception as e:
            # don't crash export on missing/bad image
            return False

    def _add_cover(self, doc, well, prefs: Optional[Preferences]):
        # logos row
        tr = doc.add_table(rows=1, cols=3).rows[0].cells
        # left logo (company)
        if prefs and prefs.logo_company and Path(prefs.logo_company).exists():
            try:
                tr[0].paragraphs[0].add_run().add_picture(str(prefs.logo_company), width=Inches(1.2))
            except: tr[0].text = ""
        else:
            tr[0].text = ""
        # center title
        tr[1].paragraphs[0].add_run("END OF WELL REPORT\n").bold=True
        tr[1].paragraphs[0].runs[0].font.size = Pt(22)
        # right logo (client)
        if prefs and prefs.logo_client and Path(prefs.logo_client).exists():
            try:
                tr[2].paragraphs[0].add_run().add_picture(str(prefs.logo_client), width=Inches(1.2))
            except: tr[2].text = ""
        else:
            tr[2].text = ""
        # metadata table
        tbl = doc.add_table(rows=0, cols=2)
        def addrow(k,v):
            r = tbl.add_row().cells; r[0].text=k; r[1].text=str(v or "")
        addrow("Well Name", well.name); addrow("Project", getattr(well.project,"name",""))
        addrow("Operator", well.operator); addrow("Rig", well.rig_name)
        addrow("Spud Date", fmt_date(well.spud_date)); addrow("Estimated Final MD (m)", well.final_depth_md_m)
        doc.add_page_break()

    # ---------------- Sections (condensed but full) ----------------
    def _section_well_info(self, doc, well):
        doc.add_heading("Well Information", level=1)
        tbl = doc.add_table(rows=0, cols=2)
        def r(k,v): c=tbl.add_row().cells; c[0].text=k; c[1].text=str(v or "")
        r("Well Name", well.name); r("Field", well.project.field if well.project else "")
        r("Well Type", well.well_type); r("Shape", well.well_shape)
        r("GLE/RTE/MSL", f"{well.gle}/{well.rte}/{well.msl}")
        r("Coordinates (Lat/Lon)", f"{well.lat}/{well.lon}")
        r("Supervisors (Day/Night)", f"{well.supervisors_day}/{well.supervisors_night}")
        doc.add_paragraph("Objectives:"); doc.add_paragraph(well.objectives or "")
        doc.add_page_break()

    def _section_daily_reports(self, doc, well, session, include_sections):
        doc.add_heading("Daily Reports (Chronological)", level=1)
        for sec in well.sections:
            if include_sections and sec.id not in include_sections and sec.name not in include_sections:
                continue
            doc.add_heading(f"Section: {sec.name}", level=2)
            reports = session.query(DailyReport).filter_by(section_id=sec.id).order_by(DailyReport.report_date).all()
            if not reports:
                doc.add_paragraph("No daily reports.")
                continue
            for dr in reports:
                doc.add_heading(f"{fmt_date(dr.report_date)} (Rig Day {dr.rig_day})", level=3)
                doc.add_paragraph("Work Summary:"); doc.add_paragraph(dr.work_summary or "")
                # small Timelog condensed table
                tls = session.query(TimeLog).filter_by(daily_report_id=dr.id).all()
                if tls:
                    t = doc.add_table(rows=1, cols=4); hdr = t.rows[0].cells
                    hdr[0].text="From"; hdr[1].text="To"; hdr[2].text="Duration(min)"; hdr[3].text="Desc"
                    for tl in tls:
                        row = t.add_row().cells
                        row[0].text = str(tl.from_time or ""); row[1].text = str(tl.to_time or ""); row[2].text = str(tl.duration_minutes or 0)
                        row[3].text = tl.description or ""
            doc.add_page_break()

    def _section_timelog_npt(self, doc, well, session, include_sections):
        doc.add_heading("Time Log Summary & NPT", level=1)
        code_min = {}
        total_npt = 0
        for sec in well.sections:
            if include_sections and sec.id not in include_sections and sec.name not in include_sections:
                continue
            tls = session.query(TimeLog).join(DailyReport).filter(DailyReport.section_id==sec.id).all()
            for t in tls:
                key = t.main_code.code if t.main_code else "UNSPEC"
                code_min[key] = code_min.get(key,0) + (t.duration_minutes or 0)
                if getattr(t, "is_npt", False):
                    total_npt += (t.duration_minutes or 0)
        doc.add_paragraph(f"Total NPT minutes: {total_npt}")
        if code_min:
            tbl = doc.add_table(rows=1, cols=2); hdr=tbl.rows[0].cells; hdr[0].text="Code"; hdr[1].text="Minutes"
            for k,v in sorted(code_min.items(), key=lambda x:-x[1]):
                rr = tbl.add_row().cells; rr[0].text=k; rr[1].text=str(v)
            # chart
            self._insert_pie_chart(doc, code_min)
        doc.add_page_break()

    def _insert_pie_chart(self, doc, code_minutes: dict):
        if not code_minutes: return
        items = sorted(code_minutes.items(), key=lambda x:-x[1])
        top = items[:8]; others = sum([v for _,v in items[8:]]) if len(items)>8 else 0
        labels = [k for k,_ in top] + (["OTHERS"] if others else [])
        sizes = [v for _,v in top] + ([others] if others else [])
        fig, ax = plt.subplots(figsize=(6,4))
        ax.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=140)
        ax.axis('equal')
        buf = BytesIO(); fig.savefig(buf, format='png', bbox_inches='tight'); plt.close(fig); buf.seek(0)
        doc.add_paragraph("Time distribution by Main Code:")
        doc.add_picture(buf, width=Inches(6))
        buf.close()

    def _section_drilling_params(self, doc, well, session):
        doc.add_heading("Drilling Parameters", level=1)
        for sec in well.sections:
            dp = session.query(DrillingParameters).filter_by(section_id=sec.id).first()
            doc.add_heading(f"Section {sec.name}", level=2)
            if not dp:
                doc.add_paragraph("No data.")
                continue
            t=doc.add_table(rows=0,cols=2)
            def rr(k,v): c=t.add_row().cells; c[0].text=k; c[1].text=str(v or "")
            rr("WOB min/max", f"{dp.wob_min}/{dp.wob_max}"); rr("Surface RPM min/max", f"{dp.rpm_surface_min}/{dp.rpm_surface_max}")
        doc.add_page_break()

    def _section_mud(self, doc, well, session):
        doc.add_heading("Mud Reports", level=1)
        for sec in well.sections:
            muds = session.query(MudReport).filter_by(section_id=sec.id).all()
            if not muds: continue
            doc.add_heading(f"Section {sec.name}", level=2)
            for m in muds:
                doc.add_paragraph(f"{fmt_date(m.sample_time)} | Type: {m.mud_type or ''}")
                t = doc.add_table(rows=0, cols=2)
                t.add_row().cells[0].text="MW (PCF)"; t.rows[-1].cells[1].text=str(m.mw_pcf or "")
                # chemicals
                if m.chemicals:
                    tbl = doc.add_table(rows=1, cols=5); hdr=tbl.rows[0].cells
                    hdr[0].text="Product"; hdr[1].text="Received"; hdr[2].text="Used"; hdr[3].text="Stock"; hdr[4].text="Unit"
                    for c in m.chemicals:
                        rr = tbl.add_row().cells; rr[0].text=c.product_type or ""; rr[1].text=str(c.received or ""); rr[2].text=str(c.used or ""); rr[3].text=str(c.stock or ""); rr[4].text=c.unit or ""
        doc.add_page_break()

    def _section_bits(self, doc, well, session, embed_images):
        doc.add_heading("Bit Records", level=1)
        for sec in well.sections:
            bits = session.query(BitRecord).filter_by(section_id=sec.id).all()
            if not bits: continue
            doc.add_heading(f"Section {sec.name}", level=2)
            for b in bits:
                doc.add_paragraph(f"Bit No {b.bit_no} | Size {b.size_in} | IADC {b.iadc_code}")
                # runs table
                if b.reports:
                    tbl = doc.add_table(rows=1, cols=8); hdr=tbl.rows[0].cells
                    hdr[0].text="WOB"; hdr[1].text="RPM"; hdr[2].text="Flow"; hdr[3].text="SPP"; hdr[4].text="PV"; hdr[5].text="YP"; hdr[6].text="ROP"; hdr[7].text="PhotoBefore/After"
                    for rr in b.reports:
                        r = tbl.add_row().cells
                        r[0].text=str(rr.wob or ""); r[1].text=str(rr.rpm or ""); r[2].text=str(rr.flowrate or ""); r[3].text=str(rr.spp or "")
                        r[4].text=str(rr.pv or ""); r[5].text=str(rr.yp or ""); r[6].text=str(rr.rop or "")
                        # attach photo links or embed
                        photo_desc = ""
                        if rr.photo_before: photo_desc += f"Before: {Path(rr.photo_before).name} "
                        if rr.photo_after: photo_desc += f"After: {Path(rr.photo_after).name}"
                        r[7].text = photo_desc
                        # embed small images below row if embed_images True and file exists
                        if embed_images:
                            if rr.photo_before and Path(rr.photo_before).exists():
                                try:
                                    doc.add_paragraph("Photo (Before):"); doc.add_picture(str(rr.photo_before), width=Inches(4))
                                except: pass
                            if rr.photo_after and Path(rr.photo_after).exists():
                                try:
                                    doc.add_paragraph("Photo (After):"); doc.add_picture(str(rr.photo_after), width=Inches(4))
                                except: pass
        doc.add_page_break()

    def _section_bha(self, doc, well, session):
        doc.add_heading("BHA Runs", level=1)
        for sec in well.sections:
            runs = session.query(BHARun).filter_by(section_id=sec.id).all()
            if not runs: continue
            doc.add_heading(f"Section {sec.name}", level=2)
            for run in runs:
                doc.add_paragraph(f"Run {run.id} | {fmt_date(run.created_at)}")
                if run.tools:
                    tbl = doc.add_table(rows=1, cols=7); hdr=tbl.rows[0].cells
                    hdr[0].text="Tool Type"; hdr[1].text="OD"; hdr[2].text="ID"; hdr[3].text="Len(m)"; hdr[4].text="Serial"; hdr[5].text="Wt(kg)"; hdr[6].text="Remarks"
                    for t in run.tools:
                        r=tbl.add_row().cells; r[0].text=t.tool_type or ""; r[1].text=str(t.od_in or ""); r[2].text=str(t.id_in or ""); r[3].text=str(t.length_m or ""); r[4].text=t.serial_no or ""; r[5].text=str(t.weight_kg or ""); r[6].text=t.remarks or ""
        doc.add_page_break()

    def _section_inventory_materials(self, doc, well, session):
        doc.add_heading("Inventory & Materials", level=1)
        for sec in well.sections:
            items = session.query(InventoryItem).filter_by(section_id=sec.id).all()
            if not items: continue
            doc.add_heading(f"Section {sec.name}", level=2)
            tbl = doc.add_table(rows=1, cols=6); hdr=tbl.rows[0].cells
            hdr[0].text="Item"; hdr[1].text="Opening"; hdr[2].text="Received"; hdr[3].text="Used"; hdr[4].text="Remaining"; hdr[5].text="Unit"
            for it in items:
                r=tbl.add_row().cells; r[0].text=it.item or ""; r[1].text=str(it.opening or ""); r[2].text=str(it.received or ""); r[3].text=str(it.used or ""); r[4].text=str(it.remaining or ""); r[5].text=it.unit or ""
            notes = session.query(MaterialNote).filter_by(section_id=sec.id).order_by(MaterialNote.note_no).all()
            if notes:
                doc.add_paragraph("Material Notes:")
                for n in notes: doc.add_paragraph(f"Note {n.note_no}: {n.text or ''}")
        doc.add_page_break()

    def _section_safety(self, doc, well, session):
        doc.add_heading("Safety & BOP", level=1)
        for sec in well.sections:
            rec = session.query(BOPRecord).filter_by(section_id=sec.id).first()
            if not rec: continue
            doc.add_heading(f"Section {sec.name}", level=2)
            doc.add_paragraph(f"Last Fire Drill: {fmt_date(rec.last_fire)} | Last BOP: {fmt_date(rec.last_bop)} | Days w/o LTI: {rec.days_without_lti}")
        doc.add_page_break()

    def _section_services_pob(self, doc, well, session):
        doc.add_heading("Services & POB", level=1)
        for sec in well.sections:
            crews = session.query(Crew).filter_by(section_id=sec.id).all()
            if not crews: continue
            doc.add_heading(f"Section {sec.name}", level=2)
            t = doc.add_table(rows=1, cols=4); hdr=t.rows[0].cells; hdr[0].text="Company"; hdr[1].text="Service"; hdr[2].text="Count"; hdr[3].text="DateIn"
            for c in crews: r=t.add_row().cells; r[0].text=c.company or ""; r[1].text=c.service or ""; r[2].text=str(c.count or ""); r[3].text=fmt_date(c.date_in)
        doc.add_page_break()

    def _section_appendices(self, doc, well, session):
        doc.add_heading("Appendices", level=1)
        for sec in well.sections:
            surveys = session.query(Survey).filter_by(section_id=sec.id).order_by(Survey.md).all()
            if not surveys: continue
            doc.add_heading(f"Survey - {sec.name}", level=2)
            tbl = doc.add_table(rows=1, cols=10)
            hdr = tbl.rows[0].cells; labels=["MD","Inc","TVD","Azi","Azimuth","North","East","VS/HD","DLS","Tool"]
            for i,lbl in enumerate(labels): hdr[i].text = lbl
            for s in surveys:
                r = tbl.add_row().cells
                r[0].text=str(s.md or ""); r[1].text=str(s.inc or ""); r[2].text=str(s.tvd or ""); r[3].text=str(s.azi or "")
                r[4].text=str(s.azimuth or ""); r[5].text=str(s.north or ""); r[6].text=str(s.east or ""); r[7].text=str(s.vs_hd or ""); r[8].text=str(s.dls or ""); r[9].text=str(s.tool or "")
        doc.add_page_break()

    def _section_signoff(self, doc, well, session, embed_images):
        doc.add_heading("Signoff", level=1)
        # Prefer well-level signoff then section-level
        sign = None
        if well.signoffs:
            sign = well.signoffs[-1]
        elif well.sections:
            # try first section signoff
            s = session.query(Signoff).filter_by(section_id=well.sections[0].id).first()
            sign = s
        if sign:
            doc.add_paragraph(f"Supervisor: {sign.supervisor_name}")
            doc.add_paragraph(f"Operation Manager: {sign.operation_manager}")
            doc.add_paragraph(f"Approved: {'Yes' if sign.approved else 'No'} at {fmt_date(sign.approved_at)}")
            if embed_images and sign.sign_image_path and Path(sign.sign_image_path).exists():
                try:
                    doc.add_paragraph("Signature:"); doc.add_picture(str(sign.sign_image_path), width=Inches(2))
                except: pass
        else:
            doc.add_paragraph("No signoff recorded.")
